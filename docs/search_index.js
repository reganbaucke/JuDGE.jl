var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#AbstractTree-Functions","page":"API Reference","title":"AbstractTree Functions","text":"","category":"section"},{"location":"api/#Defining-Trees","page":"API Reference","title":"Defining Trees","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"JuDGE.narytree\nJuDGE.tree_from_file\nJuDGE.tree_from_leaves\nJuDGE.print_tree(::AbstractTree, ::Dict{AbstractTree,T} where T <: Any)","category":"page"},{"location":"api/#JuDGE.narytree","page":"API Reference","title":"JuDGE.narytree","text":"narytree(depth::Int, degree::Int)\n\nGiven the depth and degree, this function returns an N-ary tree. Note that a depth of 0 return a single Leaf node (which is also the root node of the tree).\n\nRequired Arguments\n\ndepth is the maximum number of arcs from the root node any Leaf node\n\ndegree is the number of children of all nodes, other than the Leaf nodes\n\nExample\n\ntree = narytree(2,2)\n\n\n\n\n\n","category":"function"},{"location":"api/#JuDGE.tree_from_file","page":"API Reference","title":"JuDGE.tree_from_file","text":"tree_from_file(filename::String)\n\nConstruct tree from a file, each line in the file is of the form B,A,... representing an arc in the tree, from node \"A\" to node \"B\". The total number of columns is arbitrary. The first row of the file should be n,p,... these column headers are converted into symbols used to index the data. Each column itself converted into a dictionary, indexed by the node.\n\nRequired Arguments\n\nstring is the full path of the file containing the tree\n\nExample\n\ntree, data = tree_from_file(joinpath(@__DIR__,\"tree.csv\"))\n\n\n\n\n\n","category":"function"},{"location":"api/#JuDGE.tree_from_leaves","page":"API Reference","title":"JuDGE.tree_from_leaves","text":"tree_from_leaves(leafnodes::Array{Array{Int,1},1}, probs::Array{Float64,1})\n\nConstruct tree from Array of leaf nodes, and (optionally) the corresponding probabilities\n\nRequired Arguments\n\nleafnodes is an array of arrays defining the set of leaf nodes\n\nOptional Arguments\n\nprobs is an array of probabilities for the leaf nodes\n\nExample\n\n(tree,prob) = tree_from_leaves([[1,1,1],[1,1,2],[1,2,1],[1,2,2]],[0.25,0.25,0.25,0.25])\ntree = tree_from_leaves([[1,1,1],[1,1,2],[1,2,1],[1,2,2]])\n\n\n\n\n\n","category":"function"},{"location":"api/#JuDGE.print_tree-Tuple{AbstractTree,Dict{AbstractTree,T} where T}","page":"API Reference","title":"JuDGE.print_tree","text":"print_tree(some_tree::AbstractTree, data::Dict{AbstractTree,Any})\n\nGiven some_tree, this function prints a simple representation of the tree to the REPL.\n\nRequired Arguments\n\nsome_tree is the tree we wish to visualise\n\nOptional Arguments\n\ndata is a dictionary indexed by each node in some_tree\n\n\n\n\n\n","category":"method"},{"location":"api/#Nodes-of-Trees","page":"API Reference","title":"Nodes of Trees","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Base.collect\nJuDGE.get_leafnodes\nJuDGE.get_node","category":"page"},{"location":"api/#Base.collect","page":"API Reference","title":"Base.collect","text":"collect(tree::Tree;order=:depth)\n\nGiven tree, this function returns an array of corresponding nodes. By default this will be in a depth-first order.\n\nRequired Arguments\n\ntree is the tree from which we wish to collect the nodes\n\nOptional Arguments\n\norder can be set to :depth or :breadth to specify the order that the nodes are listed in the array.\n\nExamples\n\nnodes = collect(tree) #gets an array of nodes from tree in depth-first order\nnodes = collect(tree,order=:breadth) #gets an array of nodes from tree in breadth-first order\n\n\n\n\n\n","category":"function"},{"location":"api/#JuDGE.get_leafnodes","page":"API Reference","title":"JuDGE.get_leafnodes","text":"get_leafnodes(tree::AbstractTree)\n\nGiven tree, this function returns an array of corresponding Leaf nodes.\n\nRequired Arguments\n\ntree is the tree from which we wish to collect leaf nodes\n\nExample\n\nleafnodes = JuDGE.get_leafnodes(tree)\n\n\n\n\n\n","category":"function"},{"location":"api/#JuDGE.get_node","page":"API Reference","title":"JuDGE.get_node","text":"get_node(tree::AbstractTree, indices::Array{Int,1})\n\nGiven a tree, and an array of indices, this function returns the corresponding node in the tree.\n\nRequired Arguments\n\ntree is the tree from which we are finding the node\n\nindicies is an array of integer indices identifying a node within tree.\n\nExamples\n\nnode = get_node(tree,[1]) #get the root node\nnode = get_node(tree,[1,1]) #get the first child of the root node\nnode = get_node(tree,[1,2]) #get the second child of the root node\n\n\n\n\n\n","category":"function"},{"location":"api/#Tree-Probabilities","page":"API Reference","title":"Tree Probabilities","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"JuDGE.convert_probabilities\nJuDGE.ConditionallyUniformProbabilities\nJuDGE.UniformLeafProbabilities","category":"page"},{"location":"api/#JuDGE.convert_probabilities","page":"API Reference","title":"JuDGE.convert_probabilities","text":"convert_probabilities(tree::AbstractTree, probabilities::Dict{NodeID,Float64})\n\nGiven a dictionary of conditional probabilities for each node in tree, this function returns a dictionary that maps the NodeID of each node of tree to the corresponding unconditional probability.\n\nRequired Arguments\n\ntree is the tree that the probabilities pertain to\n\nprobabilities is a dictionary of condition probabilities for each node in tree\n\nExample\n\nprobs = JuDGE.convert_probabilities(tree,probabilities)\n\n\n\n\n\n","category":"function"},{"location":"api/#JuDGE.ConditionallyUniformProbabilities","page":"API Reference","title":"JuDGE.ConditionallyUniformProbabilities","text":"ConditionallyUniformProbabilities(tree::AbstractTree)\n\nGiven a tree, this function returns a dictionary which maps nodes of the tree to probabilities, given that there are conditionally uniform probabilities over the children of any node.\n\nRequired Arguments\n\ntree is the tree for which the probability distribution will be generated\n\nExample\n\nprobs = ConditionallyUniformProbabilities(tree)\n\n\n\n\n\n","category":"function"},{"location":"api/#JuDGE.UniformLeafProbabilities","page":"API Reference","title":"JuDGE.UniformLeafProbabilities","text":"UniformLeafProbabilities(tree::AbstractTree)\n\nGiven a tree, this function returns a dictionary which maps nodes of the tree to probabilities, given that there is a uniform distribution over the leaf nodes\n\nRequired Arguments\n\ntree is the tree for which the probability distribution will be generated\n\nExample\n\nprobs = UniformLeafProbabilities(tree)\n\n\n\n\n\n","category":"function"},{"location":"api/#Other-Tree-functions","page":"API Reference","title":"Other Tree functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"JuDGE.depth\nJuDGE.history\nJuDGE.visualize_tree\nJuDGE.get_groups","category":"page"},{"location":"api/#JuDGE.depth","page":"API Reference","title":"JuDGE.depth","text":"depth(tree::AbstractTree)\n\nGiven tree, this function returns the depth. The root node has a depth of 0.\n\nRequired Arguments\n\ntree is the node we wish to find the depth for.\n\nExample\n\ndepth = JuDGE.depth(tree) #returns the depth of a node in a tree\n\n\n\n\n\n","category":"function"},{"location":"api/#JuDGE.history","page":"API Reference","title":"JuDGE.history","text":"history(tree::AbstractTree)\n\nGiven tree, this function returns the history back up to the root node of tree.\n\nRequired Arguments\n\ntree is the node that we wish to find the history for.\n\nExample\n\nhistory = JuDGE.history(tree) #get a vector of nodes that precede tree\n\n\n\n\n\n","category":"function"},{"location":"api/#JuDGE.visualize_tree","page":"API Reference","title":"JuDGE.visualize_tree","text":"visualize_tree(some_tree::AbstractTree,\n    data::Union{Dict{Symbol,Any},Dict{Symbol,Dict{AbstractTree,Float64}}};\n    scale_edges=nothing,\n    scale_all=1.0)\n\nGiven some_tree, this function generates a html/js visualization of the tree.\n\nRequired Arguments\n\nsome_tree is the tree we wish to visualise.\n\ndata is a dictionary of the data we wish to display, each element is another dictionary indexed by the nodes of the tree.\n\nOptional Arguments\n\nscale_edges this scales the lengths of the arcs.\n\nscale_all this scales the whole network.\n\n\n\n\n\n","category":"function"},{"location":"api/#JuDGE.get_groups","page":"API Reference","title":"JuDGE.get_groups","text":"get_groups(tree::AbstractTree; combine=0)\n\nGiven a tree, this function will split it up into an array of subtrees. These can be provided as blocks for the JuDGE.solve() function to perform partial pricing.\n\nRequired Arguments\n\ntree is the tree from which we are finding the node\n\nOptional Arguments\n\ncombine this parameter determines the size of the subtrees (higher creates larger subtrees). If set to 0, the subtrees will be the sets of paths to the leaf nodes.\n\nExamples\n\nblocks = get_groups(tree)\n\n\n\n\n\n","category":"function"},{"location":"api/#JuDGE-Functions","page":"API Reference","title":"JuDGE Functions","text":"","category":"section"},{"location":"api/#JuDGE-solving-functions","page":"API Reference","title":"JuDGE solving functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"JuDGE.JuDGEModel\nJuDGE.solve(::JuDGEModel)\nJuDGE.branch_and_price\nJuDGE.variable_branch\nJuDGE.resolve_subproblems","category":"page"},{"location":"api/#JuDGE.JuDGEModel","page":"API Reference","title":"JuDGE.JuDGEModel","text":"JuDGEModel(tree::AbstractTree,\n           probabilities,\n           sub_problem_builder::Function,\n           solver;\n           discount_factor=1.0,\n           risk=RiskNeutral(),\n           sideconstraints=nothing,\n           check=true,\n           perfect_foresight=false)\n\nDefine a JuDGE model.\n\nRequired arguments\n\ntree is a reference to a scenario tree\n\nprobabilities is either a function, which returns a dictionary of the probabilities of all nodes in a tree, or simply the dictionary itself\n\nsub_problem_builder is a function mapping a node to a JuMP model for each subproblems\n\nsolver is a reference to the optimizer used for the master problem (with appropriate settings);  this can also be a tuple containing two optimizers (one for solving the relaxation, and one for  solving the binary model)\n\nOptional arguments\n\ndiscount_factor is a number between 0 and 1 defining a constant discount factor along each arc in the scenario tree\n\nrisk can be either a Risk object, or a vector of such objects.\n\nsideconstraints is a function which specifies side constraints in the master problem, see Tutorial 9: Side-constraints for further details\n\ncheck is a boolean, which can be set to false to disable the validation of the JuDGE model.\n\nperfect_foresight is a boolean; this is an experimental feature, which creates an array of JuDGE models, one for each leaf node. This will enable users to easily compute the EVPI for the stochastic program. Also can be used for regret-based risk implementations.\n\nExamples\n\njudge = JuDGEModel(tree, ConditionallyUniformProbabilities, sub_problems,\n                                Gurobi.Optimizer)\njudge = JuDGEModel(tree, probabilities, sub_problems, CPLEX.Optimizer,\n                                discount_factor=0.9, risk=Risk(0.5,0.1)))\n\n\n\n\n\n","category":"type"},{"location":"api/#JuDGE.solve-Tuple{JuDGEModel}","page":"API Reference","title":"JuDGE.solve","text":"solve(judge::JuDGEModel;\n      termination::Termination=Termination(),\n      max_no_int::Int=typemax(Int),\n      blocks::Union{Nothing,Array{Array{AbstractTree,1},1}}=nothing,\n      warm_starts::Bool=false,\n      optimizer_attributes::Union{Nothing,Function}=nothing,\n      mp_callback::Union{Nothing,Function}=nothing,\n      prune::Float64=Inf,\n      heuristic::Union{Nothing,Function}=nothing,\n      verbose::Int=2)\n\nSolve a JuDGEModel judge without branch-and-price.\n\nRequired Arguments\n\njudge is the JuDGE model that we wish to solve.\n\nOptional Arguments\n\ntermination is a Termination object containing all the stopping conditions.\n\nmax_no_int is the maximum number of iterations yielding a fractional solution before a MIP solve is performed on the master. By default, the MIP solves will not occur until the relaxed bound gap is less than the relgap / absgap stopping conditions. To override this, set max_no_int to the negative of the number desired value.\n\nblocks specifies the groups of nodes to solve in each iteration (these groups can be generated using JuDGE.get_groups(), or created manually), after all nodes have been solved, a full pricing iteration is used to compute an updated lower bound. See advanced.jl for more details.\n\nwarm_starts boolean specifing whether to use warm starts for subproblems and binary solves of master problem.\n\noptimizer_attributes can be set to a specific function that dynamically changes optimizer attributes for the subproblems; this should only be used by people who have examined the advanced.jl example.\n\nmp_callback is a user-defined function that specifies termination conditions for MIP solves of the master problem. See examples/advanced.jl.\n\nprune is used to stop the algorithm before convergence, if a known upper bound for the problem is specified.\n\nheuristic is a user-defined function that typically would perform an improvement heuristic when a new incumbent is found.\n\nverbose if 0, all output from solve will be suppressed, if 1, the subproblem solve process will be suppressed. Default is 2.\n\nExamples\n\nJuDGE.solve(jmodel, termination=Termination(rlx_abstol=10^-6))\nJuDGE.solve(jmodel, termination=Termination(rlx_abstol=10^-6), max_no_int=-5)\n\n\n\n\n\n","category":"method"},{"location":"api/#JuDGE.branch_and_price","page":"API Reference","title":"JuDGE.branch_and_price","text":"branch_and_price(models::Union{JuDGEModel,Array{JuDGEModel,1}};\n\tbranch_method::Function=JuDGE.variable_branch,search::Symbol=:lowestLB,\n\ttermination::Termination=Termination(),\n\tmax_no_int::Int=typemax(Int),\n\tblocks::Union{Nothing,Array{AbstractTree,1}}=nothing,\n\twarm_starts::Bool=false,\n\toptimizer_attributes::Union{Nothing,Function}=nothing,\n\tmp_callback::Union{Nothing,Function}=nothing,\n\tbp_callback::Union{Nothing,Function}=nothing,\n\theuristic::Union{Nothing,Function}=nothing,\n\tverbose::Int=2)\n\nSolve a JuDGEModel judge without branch and price.\n\nRequired Arguments\n\njudge is the JuDGE model that we wish to solve.\n\nOptional Arguments\n\nbranch_method is a function specifies the way that constraints are added to create new nodes in the branchandprice tree.\n\nsearch specifies the order in which nodes are solved in the (branch-and-price) tree. Options are: :lowestLB, :depth_first_dive, :depth_first_resurface, :breadth_first.\n\ntermination is a Termination object containing all the stopping conditions.\n\nmax_no_int is the maximum number of iterations yielding a fractional solution before a MIP solve is performed on the master. By default, the MIP solves will not occur until the relaxed bound gap is less than the relgap / absgap stopping conditions. To override this, set max_no_int to the negative of the number desired value.\n\nblocks specifies the groups of nodes to solve in each iteration (these groups can be generated using JuDGE.get_groups(), or created manually), after all nodes have been solved, a full pricing iteration is used to compute an updated lower bound. See advanced.jl for more details.\n\nwarm_starts boolean specifing whether to use warm starts for subproblems and binary solves of master problem.\n\noptimizer_attributes can be set to a specific function that dynamically changes optimizer attributes for the subproblems; this should only be used by people who have examined the advanced.jl example.\n\nmp_callback is a user-defined function that specifies termination conditions for MIP solves of the master problem. See examples/advanced.jl.\n\nbp_callback is a user-defined function that allows you to modify the Termination conditions for JuDGE.solve and the search policy during the branch-and-price process.\n\nheuristic is a user-defined function that typically would perform an improvement heuristic when a new incumbent is found.\n\nverbose if 0, most output from JuDGE.solve will be suppressed, if 1, the subproblem solve process will be suppressed. Default is 2.\n\nExamples\n\nJuDGE.branch_and_price(jmodel, termination=Termination(abstol=10^-6))\nJuDGE.branch_and_price(jmodel, search=:depth_first_dive, verbose=0)\n\n\n\n\n\n","category":"function"},{"location":"api/#JuDGE.variable_branch","page":"API Reference","title":"JuDGE.variable_branch","text":"variable_branch(jmodel::JuDGEModel, inttol::Float64)\n\nThis is an in-built function that is called during branch-and-price to perform a branch. Users can define their own functions that follow this format to create new branching strategies.\n\nRequired Arguments\n\njmodel is the JuDGE model\n\ninttol is the maximum permitted deviation from binary/integer for a value to still be considered binary/integer feasible.\n\n\n\n\n\n","category":"function"},{"location":"api/#JuDGE.resolve_subproblems","page":"API Reference","title":"JuDGE.resolve_subproblems","text":"resolve_subproblems(judge::JuDGEModel)\n\nOnce a JuDGE model has converged, it is necessary to re-solve the subproblems to find the optimal decisions within each node.\n\nRequired Arguments\n\njmodel is the JuDGE model that we wish to solve.\n\nExamples\n\nresolve_subproblems(judge)\n\n\n\n\n\n","category":"function"},{"location":"api/#JuDGE-macros-for-subproblems","page":"API Reference","title":"JuDGE macros for subproblems","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"JuDGE.@expansion\nJuDGE.@shutdown\nJuDGE.@enforced\nJuDGE.@state\nJuDGE.@capitalcosts\nJuDGE.@ongoingcosts","category":"page"},{"location":"api/#JuDGE.@expansion","page":"API Reference","title":"JuDGE.@expansion","text":"expansion(model, variable, args...)\n\nDefines an expansion variable variable within a subproblem model. Note that all subproblems must have the same set of expansion variables.\n\nRequired Arguments\n\nmodel is the JuDGE subproblem that we are adding the expansion variable to\n\nvariable is the name of the variable being created, this will be continuous by default; follows JuMP syntax if defining a set of variables.\n\nOptional Arguments\n\nThis macro has a third, unnamed, argument which can be set to Con, Bin, or Int, similar to the @variable macro.\n\nlag is the number of nodes in the scenario between an expansion being decided, and it becoming available.\n\nduration is the number of consecutive nodes in the scenario over which an expansion is available.\n\nlb is the lower bound for this variable in the master problem (typically omitted).\n\nub is the upper bound for this variable in the master problem (typically omitted).\n\nExamples\n\n@expansion(model, expand[1:5], Bin) #defines an array of 5 binary variables with no lag, and unlimited lifespan\n@expansion(model, expand[1:5,1:2]>=0, lag=1) #defines a matrix of 10 continuous variables with a lag of 1, and unlimited duration\n@expansion(model, 0<=expand<=10, Int, duration=2) #defines a single integer variable with a lag of 0, and a duration of 2\n\n\n\n\n\n","category":"macro"},{"location":"api/#JuDGE.@shutdown","page":"API Reference","title":"JuDGE.@shutdown","text":"shutdown(model, variable, args...)\n\nDefines an shutdown variable variable within a subproblem model. Note that all subproblems must have the same set of shutdown variables.\n\nRequired Arguments\n\nmodel is the JuDGE subproblem that we are adding the shutdown variable to\n\nvariable is the name of the variable being created, this will be continuous by default; follows JuMP syntax if defining a set of variables.\n\nOptional Arguments\n\nThis macro has a third, unnamed, argument which can be set to Con, Bin, or Int, similar to the @variable macro.\n\nlag is the number of nodes in the scenario between an shutdown being decided, and it becoming unavailable.\n\nduration is the number of consecutive nodes in the scenario over which the shutdown will last.\n\nlb is the lower bound for this variable in the master problem (typically omitted).\n\nub is the upper bound for this variable in the master problem (typically omitted).\n\nExamples\n\n@shutdown(model, shut[1:5], Bin) #defines an array of 5 binary variables with no lag, and unlimited lifespan\n@shutdown(model, shut[1:5,1:2]>=0, lag=1) #defines a matrix of 10 continuous variables with a lag of 1, and unlimited duration\n@shutdown(model, 0<=shut<=10, Int, duration=2) #defines a single integer variable with a lag of 0, and a duration of 2\n\n\n\n\n\n","category":"macro"},{"location":"api/#JuDGE.@enforced","page":"API Reference","title":"JuDGE.@enforced","text":"enforced(model, variable, args...)\n\nDefines an enforced variable variable within a subproblem model. Note that all subproblems must have the same set of enforced variables. These variables can be used as either expansion or shutdown variables, but since the constraint in the master problem is an equality, convergence is more difficult since there is less flexibility when solving the master problem.\n\nRequired Arguments\n\nmodel is the JuDGE subproblem that we are adding the expansion variable to\n\nvariable is the name of the variable being created, this will be continuous by default; follows JuMP syntax if defining a set of variables.\n\nOptional Arguments\n\nThis macro has a third, unnamed, argument which can be set to Con, Bin, or Int, similar to the @variable macro.\n\nlag is the number of nodes in the scenario between an expansion being decided, and it becoming available.\n\nduration is the number of consecutive nodes in the scenario over which an expansion is available.\n\nlb is the lower bound for this variable in the master problem (typically omitted).\n\nub is the upper bound for this variable in the master problem (typically omitted).\n\npenalty is a placeholder for a future feature, which may allow the violation of master/subproblem equality constraint, at a cost.\n\nExamples\n\n@expansion(model, forced[1:5], Bin) #defines an array of 5 binary variables with no lag, and unlimited lifespan\n@expansion(model, forced[1:5,1:2]>=0, lag=1) #defines a matrix of 10 continuous variables with a lag of 1, and unlimited duration\n@expansion(model, 0<=forced<=10, Int, duration=2) #defines a single integer variable with a lag of 0, and a duration of 2\n\n\n\n\n\n","category":"macro"},{"location":"api/#JuDGE.@state","page":"API Reference","title":"JuDGE.@state","text":"state(model, variable, args...)\n\nDefines a state variable variable within a subproblem model. Note that all subproblems must have the same set of state variables. These variables can be used to model inventory that is carried forward between the subproblems.\n\nRequired Arguments\n\nmodel is the JuDGE subproblem that we are adding the expansion variable to\n\nvariable is the name of the variable being created in the subproblem, this will be continuous by default; follows JuMP syntax if defining a set of variables. The subproblem variable corresponds to the change in the state.\n\nOptional Arguments\n\nThis macro has a third, unnamed, argument which can be set to Con, Bin, or Int, similar to the @variable macro.\n\nstate_name is the name for the state variable in the master problem. If omitted, the name of the master problem variable will match the subproblem variable (but this may cause confusion, since only the master problem variable is the state). See the inventory.jl example to see how this should be implemented.\n\ninitial is the initial value for the master problem's state variable at the root node.\n\nlb is the lower bound for the variable in the master problem (typically omitted).\n\nub is the upper bound for the variable in the master problem (typically omitted).\n\nExamples\n\n@state(sp, -50<=Δstock<=50, state_name=stock, lb=0, ub=200, initial=0) #defines a state variable called stock in the master\n                                                                       #(starting at 0, and able to take values 0 to 200),\n                                                                       #and Δstock in the subproblem (able to change the stock level by ±50).\n\n\n\n\n\n","category":"macro"},{"location":"api/#JuDGE.@capitalcosts","page":"API Reference","title":"JuDGE.@capitalcosts","text":"capitalcosts(model, expr)\n\nDefines a linear expression specifying the capital cost of expansions and shutdowns at the current node\n\nRequired Arguments\n\nmodel is the JuDGE subproblem corresponding to the node in the scenario tree that we are adding specifying the costs for\n\nexpr is an AffExpr which gives the total cost of choosing expansion and shutdown variables at the current node\n\nExample\n\n@capitalcosts(model, sum(expand[i]*cost[node][i] for i in 1:5))\n\n\n\n\n\n","category":"macro"},{"location":"api/#JuDGE.@ongoingcosts","page":"API Reference","title":"JuDGE.@ongoingcosts","text":"ongoingcosts(model, expr)\n\nDefines a linear expression specifying the ongoing costs of expansions and shutdowns available at the current node\n\nRequired Arguments\n\nmodel is the JuDGE subproblem corresponding to the node in the scenario tree that we are adding specifying the costs for\n\nexpr is an AffExpr which gives the ongoing cost of expansions and shutdowns available at the current node\n\nExample\n\n@ongoingcosts(model, sum(expand[i]*ongoingcosts[node][i] for i in 1:5))\n\n\n\n\n\n","category":"macro"},{"location":"api/#JuDGE-Output","page":"API Reference","title":"JuDGE Output","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"JuDGE.write_solution_to_file(::JuDGEModel,::String)\nJuDGE.print_expansions(::JuDGEModel)","category":"page"},{"location":"api/#JuDGE.write_solution_to_file-Tuple{JuDGEModel,String}","page":"API Reference","title":"JuDGE.write_solution_to_file","text":"write_solution_to_file(jmodel::JuDGEModel,filename::String)\n\nGiven a JuDGE model and a filename, this function writes the entire solution to a CSV.\n\nRequired Arguments\n\njmodel is the JuDGE model whose solution we wish to write to a file\n\nfilename is the output filename\n\n\n\n\n\n","category":"method"},{"location":"api/#JuDGE.print_expansions-Tuple{JuDGEModel}","page":"API Reference","title":"JuDGE.print_expansions","text":"print_expansions(jmodel::JuDGEModel;\n                 onlynonzero::Bool=true,\n                 inttol=10^-9,\n                 format=nothing)\n\nGiven a solved JuDGE model, this function will write the optimal capacity expansion decisions to the REPL.\n\nRequired Arguments\n\njmodel is the JuDGE model whose solution we wish to write to a file\n\nOptional Arguments\n\nonlynonzero is a boolean, if set to true the function will only print expansions with a non-zero value.\n\ninttol is the integrality tolerance; any expansion variable value less than this will be treated as 0, and any value greater than 1-inttol will be treated as 1\n\nformat is a function that specifies customised printing of expansion values. See Tutorial 2: Formatting output for more details.\n\n\n\n\n\n","category":"method"},{"location":"api/#Deterministic-Equivalent","page":"API Reference","title":"Deterministic Equivalent","text":"","category":"section"},{"location":"api/#Define-and-solve-DetEq-model","page":"API Reference","title":"Define and solve DetEq model","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"JuDGE.DetEqModel\nJuDGE.solve(::DetEqModel)","category":"page"},{"location":"api/#JuDGE.DetEqModel","page":"API Reference","title":"JuDGE.DetEqModel","text":"DetEqModel(tree::AbstractTree,\n           probabilities,\n           sub_problem_builder::Function,\n           solver\n           discount_factor=1.0,\n           risk=RiskNeutral,\n           sideconstraints=nothing,\n           parallel=false,\n           check=true)\n\nDefine a deterministic equivalent model for the stochastic capacity expansion problem.\n\nRequired arguments\n\ntree is a reference to a scenario tree\n\nprobabilities is either a function, which returns a dictionary of the probabilities of all nodes in a tree, or simply the dictionary itself\n\nsub_problem_builder is a function mapping a node to a JuMP model for each subproblems\n\nsolver is a reference to the optimizer used for this problem (with appropriate settings)\n\nOptional arguments\n\ndiscount_factor is a number between 0 and 1 defining a constant discount factor along each arc in the scenario tree\n\nrisk is a tuple with the two CVaR parameters: (λ, α)\n\nsideconstraints is a function which specifies side constraints in the master problem, see Tutorial 9: Side-constraints for further details.\n\nparallel is a boolean, setting whether the sub-problems will be formulated in parallel\n\ncheck is a boolean, which can be set to false to disable the validation of the JuDGE model.\n\nExamples\n\ndeteq = DetEqModel(tree, ConditionallyUniformProbabilities, sub_problems,\n                                Gurobi.Optimizer)\njudge = DetEqModel(tree, probabilities, sub_problems, CPLEX.Optimizer,\n                                discount_factor=0.9, risk=(0.5,0.1)))\n\n\n\n\n\n","category":"type"},{"location":"api/#JuDGE.solve-Tuple{DetEqModel}","page":"API Reference","title":"JuDGE.solve","text":"solve(deteq::DetEqModel)\n\nSolve a determinisitc equivalent model.\n\nRequired Arguments\n\ndeteq is the determinisitc equivalent model that we wish to solve.\n\nExample\n\nJuDGE.solve(deteq)\n\n\n\n\n\n","category":"method"},{"location":"api/#Deterministic-Equivalent-Output","page":"API Reference","title":"Deterministic Equivalent Output","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"JuDGE.write_solution_to_file(::DetEqModel,::String)\nJuDGE.print_expansions(::DetEqModel)","category":"page"},{"location":"api/#JuDGE.write_solution_to_file-Tuple{DetEqModel,String}","page":"API Reference","title":"JuDGE.write_solution_to_file","text":"write_solution_to_file(deteq::DetEqModel,filename::String)\n\nGiven a deterministic equivalent model and a filename, this function writes the entire solution to a CSV.\n\nRequired Arguments\n\ndeteq is the deterministic equivalent model whose solution we wish to write to a file\n\nfilename is the output filename\n\n\n\n\n\n","category":"method"},{"location":"api/#JuDGE.print_expansions-Tuple{DetEqModel}","page":"API Reference","title":"JuDGE.print_expansions","text":"print_expansions(deteq::DetEqModel;\n                 onlynonzero::Bool=true,\n                 inttol=10^-9,\n                 format=nothing)\n\nGiven a solved deterministic equivalent model, this function will write the optimal capacity expansion decisions to the REPL.\n\nRequired Arguments\n\ndeteq is the deterministic equivalent model whose solution we wish to write to a file\n\nOptional Arguments\n\nonlynonzero is a boolean, if set to true the function will only print expansions with a non-zero value.\n\ninttol is the integrality tolerance; any expansion variable value less than this will be treated as 0, and any value greater than 1-inttol will be treated as 1\n\nformat is a function that specifies customised printing of expansion values. See Tutorial 2: Formatting output for more details.\n\n\n\n\n\n","category":"method"},{"location":"api/#Risk","page":"API Reference","title":"Risk","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"JuDGE.RiskNeutral()\nJuDGE.Risk(::Float64,::Float64;::Union{Dict{Leaf,Float64},Nothing},::Union{Float64,Nothing},::Float64)\nJuDGE.Risk(::Float64;::Union{Dict{Leaf,Float64},Nothing},::Union{Float64,Nothing},::Float64)","category":"page"},{"location":"api/#JuDGE.RiskNeutral-Tuple{}","page":"API Reference","title":"JuDGE.RiskNeutral","text":"RiskNeutral()\n\nCreate a risk-neutral risk measure.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuDGE.Risk-Tuple{Float64,Float64}","page":"API Reference","title":"JuDGE.Risk","text":"Risk(λ::Float64,\n     α::Float64;\n     offset::Union{Dict{Leaf,Float64},Nothing}=nothing,\n     bound::Union{Float64,Nothing}=nothing,\n     penalty::Float64=100000.0)\n\nDefine the CVaR risk measure to be applied to the accumulated profits at the leaf nodes.\n\nRequired Arguments\n\nλ is weighting applied for the risk measure (max sum of weightings should be 1.0), if sum of weightings is less than 1.0, expected value will make up the rest.\n\nα is the probability in the tail of the distribution\n\nOptional Arguments\n\noffset applies a negative offset to each leaf node. This can be used to reorder the outcomes prior to applying the risk measure.\n\nbound if used, this will create a constraint on CVaR(α) with this as the upper bound.\n\npenalty if a constraint on CVaR is applied, then the marginal cost of violating the constraint is penalty.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuDGE.Risk-Tuple{Float64}","page":"API Reference","title":"JuDGE.Risk","text":"Risk(λ::Float64,\n     α::Float64;\n     offset::Union{Dict{Leaf,Float64},Nothing}=nothing,\n     bound::Union{Float64,Nothing}=nothing,\n     penalty::Float64=100000.0)\n\nDefine the CVaR risk constraint to be applied to the accumulated profits at the leaf nodes.\n\nRequired Arguments\n\nα is the probability in the tail of the distribution\n\nOptional Arguments\n\noffset applies a negative offset to each leaf node. This can be used to reorder the outcomes prior to applying the risk measure.\n\nbound if used, this will create a constraint on CVaR(α) with this as the upper bound.\n\npenalty if a constraint on CVaR is applied, then the marginal cost of violating the constraint is penalty.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/#Tutorial-1:-A-basic-JuDGE-model","page":"Tutorials","title":"Tutorial 1: A basic JuDGE model","text":"","category":"section"},{"location":"tutorials/#Problem-description","page":"Tutorials","title":"Problem description","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"For our tutorial, we will consider the following optimization problem: Our goal is minimize the cost of a stochastic sequence of knapsack problems. We represent the stochastic process with a discrete scenario tree. At each node in the scenario tree, we solve a knapsack problem. However at any point in the tree, we have the ability to expand the capacity of our knapsack at a certain cost. Once the capacity of our bag has been expanded, we are able use the extra volume for future knapsack problems from this node of the tree forward.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"In this optimization problem, we are trading off against the cost of expanding our knapsack, versus the ability to fit more into our knapsack. Deciding when to perform the knapsack expansion is the difficult part of this optimization problem.","category":"page"},{"location":"tutorials/#Solving-our-problem-using-JuDGE","page":"Tutorials","title":"Solving our problem using JuDGE","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Let us first load the packages that we need to create and solve some simple JuDGE models.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"using JuDGE, JuMP, GLPK","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The lifecycle of a JuDGEModel is the following:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The definition of a Tree;\ndefining the subproblems of the JuDGEModel;\nbuilding the JuDGEModel;\nsolving the JuDGEModel.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The user's job is to complete Steps 1 and 2, while JuDGE will automatically perform Steps 3 and 4.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"A Tree can be built in many different ways. A Tree simply consists of the root node of the tree, and a list of all the nodes in the tree. This is defined as a nested set of subtrees, with the final nodes being Leaf nodes. Each subtree simply defines its parent and children, and there are functions that facilitate the probability of arriving at the node, and the data that corresponds to the node, can be referenced through dictionaries.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"For now, we will build a tree of depth 2, where each node has 2 children with uniform probabilities using narytree:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"mytree = narytree(2,2)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"mytree is a tree which contains 7 nodes, with depth 2, and degree 2. (A depth of 0, gives only a single leaf node.) We can visualise the tree using","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"JuDGE.print_tree(mytree)","category":"page"},{"location":"tutorials/#Problem-data","page":"Tutorials","title":"Problem data","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Let us now associate our tree with the problem data.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"For our instance of the problem, we will use the following data: for each node, we will have a knapsack problem with five items to choose from, each with different rewards, and different volumes. The structure of this data is arbitrary; JuDGE just needs to be able to access the relevant data, based on the node being processed (dictionaries or functions are recommended).","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"invest_cost = Dict( zip( collect(mytree,order=:breadth), [15, 8, 8, 4, 4, 4, 4]) )\n\n\nitem_volume = Dict( zip( collect(mytree,order=:breadth), [ [4, 3, 3, 1, 2],\n                                                           [5, 3, 4, 2, 1],\n                                                           [5, 4, 2, 7, 2],\n                                                           [5, 4, 1, 8, 2],\n                                                           [3, 1, 5, 6, 3],\n                                                           [2, 5, 8, 4, 6],\n                                                           [7, 5, 4, 2, 3] ]) )\n\nitem_reward = Dict( zip( collect(mytree,order=:breadth), [ [32, 9, 9, 4, 8],\n                                                           [30, 12, 40, 10, 9],\n                                                           [20, 28, 12, 42, 12],\n                                                           [40, 28, 9, 24, 10],\n                                                           [15, 7, 20, 48, 12],\n                                                           [10, 30, 54, 32, 30],\n                                                           [32, 25, 24, 14, 24] ]) )","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"We can print the tree again and display a parameter for each node:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"JuDGE.print_tree(mytree,item_reward)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"We also define some other parameters that apply to all the nodes.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"num_items = 5\nnum_invest = 6\ninitial_volume = 6\ninvest_volume = [2,2,2,3,3,3]","category":"page"},{"location":"tutorials/#Subproblems","page":"Tutorials","title":"Subproblems","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"We need to now define the subproblems. These are JuMP models with some JuDGE- specific features. For our knapsack problem:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"JuDGE_SP_Solver = optimizer_with_attributes(GLPK.Optimizer, \"msg_lev\" => 0, \"mip_gap\" => 0.0)\nfunction sub_problems(node)\n   sp = Model(JuDGE_SP_Solver)\n\n   @expansion(sp, invest[1:num_invest], Bin)\n   @capitalcosts(sp, sum(invest[i]*invest_volume[i] for i=1:num_invest)*invest_cost[node])\n\n   @variable(sp, y[1:num_items], Bin)\n\n   @constraint(sp, BagExtension, sum(y[i]*item_volume[node][i] for i in 1:num_items) <=\n        initial_volume + sum(invest_volume[i] * invest[i] for i in 1:num_invest))\n\n   @objective(sp, Min, sum(-item_reward[node][i] * y[i] for i in 1:num_items))\n\n   return sp\nend","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The two elements of this that make it a JuDGE subproblem are:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"@expansion(model, ...) This defines the expansion variables, and supports standard JuMP vectorized variable declaration. In this case these are binary.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"@capitalcosts This declares an expression for the costs of investment; this must be linear (an AffExpr).","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The overall optimization problem at each node problem is a classical knapsack problem. We have specified the initial volume of the knapsack is initial_volume, and the each expansion increases the volume of the knapsack by the corresponding value in invest_volume.","category":"page"},{"location":"tutorials/#Solving-the-JuDGE-Model","page":"Tutorials","title":"Solving the JuDGE Model","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Now with our tree built and the problem data referenced, we can initialize the JuDGEModel based on our tree, subproblems, and solver.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"JuDGE_MP_Solver = optimizer_with_attributes((method=GLPK.INTERIOR) -> GLPK.Optimizer(),\n\t\t\t\t\t\t\t\"msg_lev\" => 0, \"mip_gap\" => 0.0)\njudy = JuDGEModel(mytree, ConditionallyUniformProbabilities, sub_problems, JuDGE_MP_Solver)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"ConditionallyUniformProbabilities simply applies a uniform conditional probability distribution for child nodes. Either a function or a dictionary, which maps nodes to absolute probabilities, can be used here.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"At this point, we have constructed a valid JuDGEModel.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"There are a number of optional stopping criteria that can be set:     abstol, reltol, rlx_abstol, rlx_reltol, time_limit, max_iter.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"These are grouped within a Termination struct that can be defined with as many termination conditions as required (if any condition is met, the solve is stopped). There are defaults for all stopping criteria, so it is not necessary to provide the Termination object to the JuDGE.solve function.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"We can now solve our model by making a call to JuDGE.solve:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"JuDGE.solve(judy,termination=Termination(rlx_abstol=10^-7),verbose=1)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Currently, we recommend using JuDGE with Gurobi as the subproblem and master problem solvers. Any solvers can be specified, but the master problem must return duals, and an interior point method is recommended for reliable convergence. The subproblems can be solved with any method. (If you do not solve the subproblems to a zero bound-gap, the upper and lower bounds will not fully converge; it is therefore also necessary to set appropriate convergence tolerances in the master problem.)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"We can view the optimal solution to our problem by calling","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"println(\"Objective: \"*string(JuDGE.get_objval(judy))\nJuDGE.print_expansions(judy)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Finally, if we want to recover the optimal solutions for the nodes, we must fix the investments and resolve each subproblem, after which we can write the solution to a CSV file.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"println(\"Re-solved Objective: \" * string(resolve_subproblems(judy)))","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"JuDGE.write_solution_to_file(judy,joinpath(@__DIR__,\"knapsack_solution.csv\"))","category":"page"},{"location":"tutorials/#Tutorial-2:-Formatting-output","page":"Tutorials","title":"Tutorial 2: Formatting output","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Since the expansion variables are all binary, the print_expansions function doesn't directly convey how much capacity is built. In order to output more information about the capacity it's possible to write a custom function that is supplied as an optional argument format. First, let us simply provide the capacity associated with each decision.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"function format_output(s::Symbol,value)\n   if s==:invest\n      output=Dict{Int,Float64}()\n      for i in 1:num_invest\n         output[i]=invest_volume[i]*value[i]\n      end\n\t  return output\n   end\n   return nothing\nend\n\nJuDGE.print_expansions(judy, format=format_output)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"We can also aggregate the capacities of all the expansions.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"function format_output(s::Symbol,value)\n   if s==:invest\n\t  return sum(invest_volume[i]*value[i] for i in 1:num_invest)\n   end\n   return nothing\nend\n\nJuDGE.print_expansions(judy, format=format_output)","category":"page"},{"location":"tutorials/#Tutorial-3:-Ongoing-costs","page":"Tutorials","title":"Tutorial 3: Ongoing costs","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Depending on the capacity planning application that JuDGE is being applied to there may be ongoing upkeep / maintenance costs for the expansions. This is modelled within JuDGE by using the @ongoingcosts macro to specify the cost of the expansions being available at each node in the scenario tree. (That is, the corresponding expansion variable has been set to 1 in the master problem.) If there are costs that can be avoided, by not making use of capacity that is granted, then this should be modelled within the @objective.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"function sub_problems_ongoing(node)\n   sp = Model(JuDGE_SP_Solver)\n   @expansion(sp, invest[1:num_invest], Bin)\n\t@capitalcosts(sp, sum(invest[i]*invest_volume[i] for i=1:num_invest)*invest_cost[node])\n\t@ongoingcosts(sp, sum(invest[i]*invest_volume[i] for i=1:num_invest)*2)\n   @variable(sp, y[1:num_items], Bin)\n   @constraint(sp, BagExtension, sum(y[i]*item_volume[node][i] for i in 1:num_items) <=\n        initial_volume + sum(invest_volume[i] * invest[i] for i in 1:num_invest))\n   @objective(sp, Min, sum(-item_reward[node][i] * y[i] for i in 1:num_items))\n   return sp\nend\n\njudy = JuDGEModel(mytree, ConditionallyUniformProbabilities, sub_problems_ongoing,\n\tJuDGE_MP_Solver)\n\nJuDGE.solve(judy,verbose=1)\n\nprintln(\"Objective: \"*string(judy.bounds.UB))\nJuDGE.print_expansions(judy, format=format_output)","category":"page"},{"location":"tutorials/#Tutorial-4:-Deterministic-equivalent","page":"Tutorials","title":"Tutorial 4: Deterministic equivalent","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"JuDGE can use the tree, and subproblems to automatically construct the deterministic equivalent of the stochastic capacity expansion problem. This is created by defining a DetEqModel with the same arguments as a JuDGEModel, as follows:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"JuDGE_DE_Solver = optimizer_with_attributes(GLPK.Optimizer, \"msg_lev\" => 2, \"mip_gap\" => 0)\ndeteq = DetEqModel(mytree, ConditionallyUniformProbabilities, sub_problems, JuDGE_DE_Solver)\nJuDGE.solve(deteq)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The solution can be printed to the REPL or a CSV in the same way as a JUDGEModel.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"println(\"Deterministic Equivalent Objective: \" * string(objective_value(deteq.problem)))\nJuDGE.print_expansions(deteq, format=format_output)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"JuDGE.write_solution_to_file(judy,joinpath(@__DIR__,\"knapsack_solution.csv\"))","category":"page"},{"location":"tutorials/#Tutorial-5:-Lag-and-duration","page":"Tutorials","title":"Tutorial 5: Lag and duration","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Depending on the particular expansion problem being modelled, there may be some delay (lag) between when the expansion decision is made, and when the capacity becomes available. This can be modelled in JuDGE be specifying a lag when defining the expansion variables in the subproblems, the @expansion macro allows additional named arguments lag and duration. For a lag of 1 you would define the expansion variables as follows:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"@expansion(sp, invest[1:num_invest], Bin, lag=1)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The duration of an expansion is set to ∞ by default. However, if an expansion is temporary or otherwise has a limited lifespan, we can set the duration argument when defining the expansion variable. For example if the lag is 0 and the duration is 2, we can define it as follows:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"@expansion(sp, invest[1:num_invest], Bin, duration=2)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"We will now redefine our subproblems and re-solve our model. (Note that the invest_cost has been divided by 2.)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"function sub_problems_lag(node)\n   sp = Model(JuDGE_SP_Solver)\n   @expansion(sp, invest[1:num_invest], Bin, lag=1)\n   @capitalcosts(sp, sum(invest[i]*invest_volume[i] for i=1:num_invest)*invest_cost[node]/2)\n   @variable(sp, y[1:num_items], Bin)\n   @constraint(sp, BagExtension, sum(y[i]*item_volume[node][i] for i in 1:num_items) <=\n        initial_volume + sum(invest_volume[i] * invest[i] for i in 1:num_invest))\n   @objective(sp, Min, sum(-item_reward[node][i] * y[i] for i in 1:num_items))\n   return sp\nend\n\njudy = JuDGEModel(mytree, ConditionallyUniformProbabilities, sub_problems_lag, JuDGE_MP_Solver)\nJuDGE.solve(judy,verbose=1)\n\nprintln(\"Objective: \"*string(judy.bounds.UB))\nprintln(\"Lower Bound: \"*string(judy.bounds.LB))\nJuDGE.print_expansions(judy, format=format_output)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"We see that although this solution has ostensibly converged, the best integer is greater than the lower bound. The * in the final line of the output means that the integer solution has been found using a MIP solve for the generated columns. In order to find a provably optimal solution we must use branch-and-price.","category":"page"},{"location":"tutorials/#Tutorial-6:-Branch-and-Price","page":"Tutorials","title":"Tutorial 6: Branch and Price","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"JuDGE implements a branch-and-price algorithm for problems which are not naturally integer. It can be run with default settings as follows:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"judy = JuDGEModel(mytree, ConditionallyUniformProbabilities, sub_problems_lag, JuDGE_MP_Solver)\nbest = JuDGE.branch_and_price(judy,search=:lowestLB,branch_method=JuDGE.variable_branch,verbose=1)\n\nJuDGE.print_expansions(best, format=format_output)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"We now see that we have found a better solution, and proved it is optimal.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"There are several options for the search: :lowestLB always chooses to branch on the node with the lowest lower bound; :depth_first_dive performs a depth-first search of the branch and bound tree, once it find a node with an integer relaxation it searches adjacent nodes within the tree; :depth_first_resurface performs a depth-first search of the branch and bound tree, but once it finds a node with an integer relaxation it returns to the root node and explores the other branch; :breadth_first performs a breadth-first search of the tree.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"There is a default branching method: JuDGE.variable_branch, but it is also possible to write custom branching methods; see the API for more details.","category":"page"},{"location":"tutorials/#Tutorial-7:-Risk-aversion","page":"Tutorials","title":"Tutorial 7: Risk aversion","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"JuDGE implements risk aversion using the risk measure CVaR over the accumulated profits up to each of leaf nodes in the scenario tree. The objective function minimized is a convex combination of expectation and CVaR, with the parameter λ=1 meaning at all the weight is placed on CVaR. In our implementation CVaR represents the expected cost of the 100α% worst scenarios. In order to implement CVaR, we supply the optional argument risk=Risk(λ,α) when we construct the JuDGEModel.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"judy = JuDGEModel(mytree, ConditionallyUniformProbabilities, sub_problems, JuDGE_MP_Solver,\n\trisk=Risk(0.5,0.1))\nbest = JuDGE.branch_and_price(judy,verbose=0)\n\nprintln(\"Objective: \"*string(best.bounds.UB))\nprintln(\"Lower Bound: \"*string(best.bounds.LB))\nprintln(\"Expected Costs: \"*string(JuDGE.get_objval(best,risk=JuDGE.RiskNeutral()))\nJuDGE.print_expansions(best, format=format_output)","category":"page"},{"location":"tutorials/#Tutorial-8:-Shutdown-variables","page":"Tutorials","title":"Tutorial 8: Shutdown variables","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"JuDGE supports shutdown decisions. These are variables that remove capacity when they are activated. The @capitalcosts of these decisions may be negative, reflecting some salvage value; moreover, the @ongoingcosts may also be negative, reflecting avoided maintenance costs. Given that this is a shutdown variable, it is important to remember that the capacity being removed should be accounted for elsewhere within the subproblem.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"function sub_problems_shutdown(node)\n   model = Model(JuDGE_SP_Solver)\n   @shutdown(model, bag, Bin)\n   @capitalcosts(model, -bag*invest_cost[node])\n   @variable(model, y[1:num_items], Bin)\n   @constraint(model, BagExtension, sum(y[i]*item_volume[node][i] for i in 1:num_items) <=\n\t\t7 - bag)\n   @objective(model, Min, sum(-item_reward[node][i] * y[i] for i in 1:num_items))\n   return model\nend\n\njudy = JuDGEModel(mytree, ConditionallyUniformProbabilities, sub_problems_shutdown,\n\tJuDGE_MP_Solver)\nJuDGE.solve(judy,verbose=1)\n\nprintln(\"Objective: \"*string(objective_value(judy.master_problem)))\nJuDGE.print_expansions(judy)","category":"page"},{"location":"tutorials/#Tutorial-9:-Side-constraints","page":"Tutorials","title":"Tutorial 9: Side-constraints","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"JuDGE supports side-constraints being added to the master problem. These can be constraints across expansion variables at a single node, or can be constraints on variables corresponding to different nodes. The JuDGE.history function can be useful if applying logical constraints on expansion variables. In order to apply a budget constraint at each node we can define the following function:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"function budget(model,tree)\n   for node in collect(tree)\n      @constraint(model,sum(invest_cost[node]*invest_volume[i]*invest[node][i]\n\t\t  for i in 1:num_invest)<=40)\n   end\nend","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"We now can define a JuDGEModel with these side-constraints, and solve it using branch and price.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"judy = JuDGEModel(mytree, ConditionallyUniformProbabilities, sub_problems, JuDGE_MP_Solver,\n\tsideconstraints=budget)\njudy = JuDGE.branch_and_price(judy, search=:lowestLB, branch_method=JuDGE.constraint_branch)\nJuDGE.print_expansions(judy, format=format_output)","category":"page"},{"location":"tutorials/#Tutorial-10:-State-variables","page":"Tutorials","title":"Tutorial 10: State variables","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"JuDGE has experimental support for state variables. These are variables that are part of the master problem, and are either increased or decreased by actions within the subproblems. See the example inventory.jl for details of how these variables can be implemented.","category":"page"},{"location":"tutorials/#Tutorial-11:-Set-partitioning-/-packing-models","page":"Tutorials","title":"Tutorial 11: Set partitioning / packing models","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"JuDGE has experimental support for set partitioning / packing models. The documentation for this hasn't been written yet, but examples of a vehicle routing model (vrp.jl) and a cutting stock model (cutting_stock.jl) are provided in the examples directory.","category":"page"},{"location":"","page":"JuDGE","title":"JuDGE","text":"CurrentModule = JuDGE\nDocTestSetup = quote\n    using JuDGE\nend","category":"page"},{"location":"","page":"JuDGE","title":"JuDGE","text":"(Image: JuDGE)","category":"page"},{"location":"#JuDGE.jl","page":"JuDGE","title":"JuDGE.jl","text":"","category":"section"},{"location":"","page":"JuDGE","title":"JuDGE","text":"JuDGE stands for: Julia Decomposition for Generalized Expansion. Functionally, it is a solver which leverages the syntax of the JuMP modelling language to solve a particular class of capacity expansion problems.","category":"page"},{"location":"","page":"JuDGE","title":"JuDGE","text":"For more details see our working paper: JuDGE.jl: a Julia package for optimizing capacity expansion.","category":"page"},{"location":"#Problem-Class-/-Decomposition","page":"JuDGE","title":"Problem Class / Decomposition","text":"","category":"section"},{"location":"","page":"JuDGE","title":"JuDGE","text":"JuDGE solves multi-stage stochastic integer programming problems using Dantzig-Wolfe decomposition. The user must specify a tree that represents the uncertainty of the problem, and at each node define a subproblem that can be a linear or integer program. Further, the expansion variables which link the subproblems must be declared.","category":"page"},{"location":"","page":"JuDGE","title":"JuDGE","text":"JuDGE automatically generates a master problem and performs column generation to converge to an optimal solution.","category":"page"},{"location":"#Requirements","page":"JuDGE","title":"Requirements","text":"","category":"section"},{"location":"","page":"JuDGE","title":"JuDGE","text":"JuDGE requires Julia-1.3+, JuMP and appropriate optimiser(s). For academics, Gurobi / CPLEX provide free academic licenses, otherwise, you can use CBC/Clp or GLPK.","category":"page"},{"location":"#Installation","page":"JuDGE","title":"Installation","text":"","category":"section"},{"location":"","page":"JuDGE","title":"JuDGE","text":"JuDGE is installed by the Pkg utility provided by Julia. In the Julia REPL, simply make the following function call.","category":"page"},{"location":"","page":"JuDGE","title":"JuDGE","text":"] add \"https://github.com/reganbaucke/JuDGE.jl\"","category":"page"},{"location":"","page":"JuDGE","title":"JuDGE","text":"Then, in your Julia script, use","category":"page"},{"location":"","page":"JuDGE","title":"JuDGE","text":"using JuDGE","category":"page"},{"location":"","page":"JuDGE","title":"JuDGE","text":"to import the functions from the JuDGE module into the current namespace.","category":"page"},{"location":"#Stochastic-Knapsack-Example","page":"JuDGE","title":"Stochastic Knapsack Example","text":"","category":"section"},{"location":"","page":"JuDGE","title":"JuDGE","text":"JuDGE is distributed with an example of a multi-stage stochastic integer programming problem. This is a stochastic knapsack problem with investment. The file knapsack.jl contains the implementation of this problem within the JuDGE framework. There are also a number of variants of this model demonstrating other features of JuDGE.","category":"page"},{"location":"","page":"JuDGE","title":"JuDGE","text":"See the Tutorials for details about this.","category":"page"},{"location":"#Limitations","page":"JuDGE","title":"Limitations","text":"","category":"section"},{"location":"","page":"JuDGE","title":"JuDGE","text":"The package is currently under development, and while it has been tested on a ","category":"page"},{"location":"","page":"JuDGE","title":"JuDGE","text":"number of example problems, there may be some issues that have yet to be addressed.","category":"page"},{"location":"","page":"JuDGE","title":"JuDGE","text":"Support for decisions to reduce capacity is not fully tested.","category":"page"},{"location":"#Bugs","page":"JuDGE","title":"Bugs","text":"","category":"section"},{"location":"","page":"JuDGE","title":"JuDGE","text":"Please raise an issue if you experience an error while using JuDGE.","category":"page"}]
}
